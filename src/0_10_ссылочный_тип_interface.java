// # **Интерфейс (interface) как ссылочный тип данных в Java**

// ## **1. Интерфейс как отдельный тип данных**

// В Java интерфейсы представляют собой **особый ссылочный тип данных**, который:
// - Определяет контракт поведения без реализации
// - Может использоваться как самостоятельный тип для переменных
// - Поддерживает полиморфизм наравне с классами

// ```java
// Объявление интерфейса как типа
interface Drawable {
    void draw();
}
// ```

// ## **2. Особенности интерфейсов как ссылочного типа**

// ### **2.1. Основные характеристики**
// - **Не может быть инстанциирован** напрямую (`new Drawable()` — ошибка)
// - **Может содержать**:
//   - Абстрактные методы (по умолчанию `public abstract`)
//   - Константы (`public static final`)
//   - Дефолтные методы (Java 8+)
//   - Приватные методы (Java 9+)
//   - Статические методы (Java 8+)

// ### **2.2. Иерархия типов**
// ```java
Object
↑
interface MyInterface  // Интерфейс — отдельная ветвь в иерархии типов
↑
class MyClass implements MyInterface
// ```

// ## **3. Использование интерфейса как типа**

// ### **3.1. Объявление переменных**
// ```java
List<String> list = new ArrayList<>();  // List — интерфейс
Runnable task = () -> System.out.println("Running");  // Runnable — интерфейс
// ```

// ### **3.2. Параметры методов**
// ```java
public void process(Collection<?> items) {  // Collection — интерфейс
    // реализация
}
// ```

// ### **3.3. Возвращаемые значения**
// ```java
public Comparable<?> getComparable() {  // Comparable — интерфейс
    return Integer.valueOf(42);
}
// ```

// ## **4. Сравнение с классом как ссылочным типом**

// | Характеристика      | Интерфейс                         | Класс                      |
// |---------------------|-----------------------------------|----------------------------|
// | **Экземпляры**      | Нельзя создать напрямую           | Можно создать              |
// | **Реализация**      | Только контракт                   | Полная реализация          |
// | **Наследование**    | Множественное (implements)        | Одиночное (extends)        |
// | **Поля**            | Только константы                  | Любые поля                 |
// | **Методы**          | Абстрактные/дефолтные/статические | Полные реализации          |

// ## **5. Полиморфизм через интерфейсы**

// Интерфейсы обеспечивают мощный механизм полиморфизма:

// ```java
interface Logger {
    void log(String message);
}

class FileLogger implements Logger { /*...*/ }
class ConsoleLogger implements Logger { /*...*/ }

// Использование
Logger logger = new FileLogger();  // Полиморфное присваивание
logger.log("Test message");
// ```

// ## **6. Нововведения в современных версиях Java**

// ### **6.1. Дефолтные методы (Java 8+)**
// ```java
interface Vehicle {
    default void start() {
        System.out.println("Vehicle started");
    }
}
// ```

// ### **6.2. Приватные методы (Java 9+)**
// ```java
interface Database {
    private void connect() { /*...*/ }
    private void disconnect() { /*...*/ }
}
// ```

// ### **6.3. Статические методы (Java 8+)**
// ```java
interface MathUtils {
    static int square(int x) {
        return x * x;
    }
}
// ```

// ## **7. Примеры встроенных интерфейсов Java**

// 1. **`Comparable<T>`** — для сравнения объектов
// 2. **`Serializable`** — маркерный интерфейс сериализации
// 3. **`Runnable`** — для многопоточности
// 4. **`Collection`** — базовый интерфейс коллекций
// 5. **`Function`/`Predicate`** — функциональные интерфейсы (Java 8)

// ## **8. Практическое применение**

// ### **8.1. Снижение связности кода**
// ```java
// Вместо конкретного класса используем интерфейс
public void processData(DataProcessor processor) {
    processor.process();
}
// ```

// ### **8.2. Тестирование (Mock-объекты)**
// ```java
interface UserRepository {
    User findById(long id);
}

// В тестах можно подменить реализацию
UserRepository mockRepo = id -> new User("Test");
// ```

// ### **8.3. Функциональное программирование**
// ```java
Function<String, Integer> lengthFunc = String::length;
System.out.println(lengthFunc.apply("Java"));  // 4
// ```

// ## **9. Ограничения интерфейсов**

// 1. Не могут содержать состояние (не-final поля)
// 2. Нет конструкторов
// 3. До Java 8 не могли содержать реализацию методов
// 4. Ограниченная поддержка наследования реализации

// ## **10. Заключение**

// Интерфейсы в Java — это мощный механизм, который:
// - Определяет **контракты** поведения
// - Обеспечивает **гибкость** архитектуры
// - Поддерживает **полиморфизм**
// - Позволяет **разделять** абстракцию и реализацию

// **Рекомендации по использованию:**
// 1. Предпочитайте интерфейсы конкретным классам в объявлениях типов
// 2. Используйте принцип "программирования на уровне интерфейсов"
// 3. Комбинируйте с другими возможностями Java (лямбдами, generics)

// Интерфейсы делают код более:
// - **Гибким** (легко менять реализации)
// - **Тестируемым** (просто подменять реализации)
// - **Расширяемым** (новые реализации без изменения клиентского кода)