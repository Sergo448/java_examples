// # **Тип данных `long` в Java: полное руководство**

// ## **1. Введение в тип `long`**
// Тип `long` — это 64-битный целочисленный примитивный тип данных, 
// предназначенный для работы с **очень большими числами**.
//  Он используется, когда диапазона `int` (до 2 миллиардов) недостаточно.

// ### **Ключевые характеристики:**
// - Размер: **64 бита (8 байт)**
// - Диапазон: **-2⁶³ до 2⁶³-1** (-9 223 372 036 854 775 808 до 9 223 372 036 854 775 807)
// - Значение по умолчанию: **0L**
// - Литералы: требуют суффикс **`L`** (например, `10000000000L`).

// ---

// ## **2. Объявление и инициализация**

// ### **2.1. Базовый синтаксис**
// ```java
// long variableName = valueL;
// ```
// Примеры:
// ```java
// long universeAge = 13_800_000_000L; // Возраст Вселенной в годах
// long bitcoinSupply = 21_000_000L;   // Максимальное количество BTC
// ```

// ### **2.2. Особенности инициализации**
// - Без суффикса `L` числа >2³¹-1 вызывают ошибку:
//   ```java
//   long error = 2147483648; // Ошибка: integer number too large
//   ```
// - Можно использовать шестнадцатеричный, двоичный и восьмеричный форматы:
//   ```java
//   long hex = 0x7FFF_FFFF_FFFF_FFFFL; // Максимальное значение
//   long binary = 0b1000_0000L;        // 128
//   ```

// ---

// ## **3. Арифметические операции**

// ### **3.1. Базовые операции**
// ```java
// long a = 10_000_000_000L;
// long b = 3_000_000_000L;

// long sum = a + b;  // 13_000_000_000L
// long diff = a - b; // 7_000_000_000L
// long prod = a * b; // 30_000_000_000_000_000_000L
// ```

// ### **3.2. Переполнение (overflow)**
// При превышении максимального значения происходит циклическое переполнение:
// ```java
// long max = 9223372036854775807L;
// max++; // Становится -9223372036854775808L
// ```

// ---

// ## **4. Сравнение с другими целочисленными типами**

// | Тип          | Размер       | Диапазон                              | Использование                     |
// |--------------|--------------|---------------------------------------|-----------------------------------|
// | `int`        | 32 бита      | -2³¹..2³¹-1 (~2.1 млрд)               | Основной тип для целых чисел      |
// | `long`       | 64 бита      | -2⁶³..2⁶³-1 (~9.2 квинтиллиона)       | Очень большие числа               |
// | `BigInteger` | Произвольный | Любые целые числа                     | Числа за пределами `long`         |

// ---

// ## **5. Практическое применение**

// ### **5.1. Работа с временными метками**
// ```java
// long startTime = System.currentTimeMillis(); // Текущее время в мс
// long endTime = startTime + 3600_000L;        // +1 час
// ```

// ### **5.2. Вычисления с большими числами**
// ```java
// long factorial(int n) {
//     long result = 1L;
//     for (int i = 2; i <= n; i++) {
//         result *= i;
//     }
//     return result; // Для n=20: 2432902008176640000L
// }
// ```

// ### **5.3. Работа с большими файлами**
// ```java
// File file = new File("huge_file.zip");
// long fileSize = file.length(); // Размер файла в байтах
// ```

// ---

// ## **6. Автоупаковка и класс `Long`**

// ### **6.1. Автоматическое преобразование**
// ```java
// Long obj = 1000L;     // Автоупаковка
// long prim = obj;       // Автораспаковка
// ```

// ### **6.2. Кэширование значений**
// Класс `Long` кэширует значения от **-128 до 127** (зависит от реализации JVM):
// ```java
// Long a = 100L;
// Long b = 100L;
// System.out.println(a == b); // true (один объект)

// Long c = 1000L;
// Long d = 1000L;
// System.out.println(c == d); // false (разные объекты)
// ```

// ---

// ## **7. Рекомендации по использованию**

// **Используйте `long`, когда:**
// ✅ Работаете с числами >2.1 млрд  
// ✅ Вычисляете временные интервалы (миллисекунды, наносекунды)  
// ✅ Обрабатываете большие файлы (размеры, смещения)  
// ✅ Используете 64-битные идентификаторы (например, в базах данных)  

// **Не используйте `long`, если:**
// ❌ Числа помещаются в `int` (экономия памяти)  
// ❌ Работаете с библиотеками, требующими `int`  

// ---

// ## **8. Производительность**
// - На 64-битных JVM операции с `long` выполняются почти так же быстро, как с `int`.  
// - На 32-битных системах операции с `long` могут быть медленнее из-за отсутствия нативной поддержки.  
// - Массивы `long[]` занимают в 2 раза больше памяти, чем `int[]`.

// ---

// ## **9. Ограничения и обходные решения**
// Если диапазона `long` недостаточно, используйте `BigInteger`:
// ```java
// BigInteger hugeNumber = new BigInteger("123456789012345678901234567890");
// ```

// ---

// ## **10. Заключение**
// Тип `long` в Java — это:
// - **Основной тип для очень больших целых чисел**  
// - **Необходим** для работы с временными метками, файлами, 64-битными ID  
// - **Автоупаковка/распаковка** с классом `Long` упрощает интеграцию с коллекциями  

// **Главное правило:** Используйте `long` для чисел, выходящих за пределы `int`,
//  и для системных операций, требующих 64-битных значений.
//  Для арифметики с числами >9 квинтиллионов переходите на `BigInteger`.